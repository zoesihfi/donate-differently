'use strict';

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
var _ = {
  sum: require('lodash/sum'),
  flatten: require('lodash/flatten'),
};
var chalk = require('chalk');

/**
 * The paginator returns a subset of the choices if the list is too long.
 */

class Paginator {
  constructor(screen, options = {}) {
    const { isInfinite = true } = options;
    this.lastIndex = 0;
    this.screen = screen;
    this.isInfinite = isInfinite;
<<<<<<< HEAD
=======
var _ = require('lodash');
var chalk = require('chalk');

/**
 * The paginator keeps track of a pointer index in a list and returns
 * a subset of the choices if the list is too long.
 */

class Paginator {
  constructor(screen) {
    this.pointer = 0;
    this.lastIndex = 0;
    this.screen = screen;
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  }

  paginate(output, active, pageSize) {
    pageSize = pageSize || 7;
<<<<<<< HEAD
<<<<<<< HEAD
=======
    var middleOfList = Math.floor(pageSize / 2);
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    var lines = output.split('\n');

    if (this.screen) {
      lines = this.screen.breakLines(lines);
<<<<<<< HEAD
<<<<<<< HEAD
      active = _.sum(lines.map((lineParts) => lineParts.length).splice(0, active));
=======
      active = _.sum(lines.map(lineParts => lineParts.length).splice(0, active));
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
      active = _.sum(lines.map((lineParts) => lineParts.length).splice(0, active));
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
      lines = _.flatten(lines);
    }

    // Make sure there's enough lines to paginate
    if (lines.length <= pageSize) {
      return output;
    }
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    const visibleLines = this.isInfinite
      ? this.getInfiniteLines(lines, active, pageSize)
      : this.getFiniteLines(lines, active, pageSize);
    this.lastIndex = active;
    return (
      visibleLines.join('\n') +
      '\n' +
      chalk.dim('(Move up and down to reveal more choices)')
    );
  }

  getInfiniteLines(lines, active, pageSize) {
    if (this.pointer === undefined) {
      this.pointer = 0;
    }
    var middleOfList = Math.floor(pageSize / 2);
<<<<<<< HEAD
=======

>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    // Move the pointer only when the user go down and limit it to the middle of the list
    if (
      this.pointer < middleOfList &&
      this.lastIndex < active &&
      active - this.lastIndex < pageSize
    ) {
      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);
    }

<<<<<<< HEAD
<<<<<<< HEAD
=======
    this.lastIndex = active;

>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    // Duplicate the lines so it give an infinite list look
    var infinite = _.flatten([lines, lines, lines]);
    var topIndex = Math.max(0, active + lines.length - this.pointer);

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    return infinite.splice(topIndex, pageSize);
  }

  getFiniteLines(lines, active, pageSize) {
    var topIndex = active - pageSize / 2;
    if (topIndex < 0) {
      topIndex = 0;
    } else if (topIndex + pageSize > lines.length) {
      topIndex = lines.length - pageSize;
    }
    return lines.splice(topIndex, pageSize);
<<<<<<< HEAD
=======
    var section = infinite.splice(topIndex, pageSize).join('\n');
    return section + '\n' + chalk.dim('(Move up and down to reveal more choices)');
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  }
}

module.exports = Paginator;
