# Enforces consistent returning of awaited values (`return-await`)

Returning an awaited promise can make sense for better stack trace information as well as for consistent error handling (returned promises will not be caught in an async function try/catch).

## Rule Details

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
This rule builds on top of the [`eslint/no-return-await`](https://eslint.org/docs/rules/no-return-await) rule.
It expands upon the base rule to add support for optionally requiring `return await` in certain cases.

## How to use

```jsonc
{
  // note you must disable the base rule as it can report incorrect errors
  "no-return-await": "off",
  "@typescript-eslint/return-await": "error"
}
```

## Options

```ts
type Options = 'in-try-catch' | 'always' | 'never';

const defaultOptions: Options = 'in-try-catch';
```

### `in-try-catch`

Requires that a returned promise must be `await`ed in `try-catch-finally` blocks, and disallows it elsewhere.

Examples of **incorrect** code with `in-try-catch`:

```ts
async function invalidInTryCatch1() {
  try {
    return Promise.resolve('try');
  } catch (e) {}
}

async function invalidInTryCatch2() {
  return await Promise.resolve('try');
}

async function invalidInTryCatch3() {
  return await 'value';
}
```

Examples of **correct** code with `in-try-catch`:

```ts
async function validInTryCatch1() {
<<<<<<< HEAD
=======
The `@typescript-eslint/return-await` rule specifies that awaiting a returned non-promise is never allowed. By default, the rule requires awaiting a returned promise in a `try-catch-finally` block and disallows returning an awaited promise in any other context. Optionally, the rule can require awaiting returned promises in all contexts, or disallow them in all contexts.

## Options

`in-try-catch` (default): `await`-ing a returned promise is required in `try-catch-finally` blocks and disallowed elsewhere.

`always`: `await`-ing a returned promise is required everywhere.

`never`: `await`-ing a returned promise is disallowed everywhere.

```typescript
// valid in-try-catch
async function validInTryCatch1() {
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  try {
    return await Promise.resolve('try');
  } catch (e) {}
}

async function validInTryCatch2() {
  return Promise.resolve('try');
}

async function validInTryCatch3() {
  return 'value';
}
<<<<<<< HEAD

// valid always
async function validAlways1() {
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
  try {
    return await Promise.resolve('try');
  } catch (e) {}
}

<<<<<<< HEAD
async function validInTryCatch2() {
  return Promise.resolve('try');
}

async function validInTryCatch3() {
  return 'value';
}
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
```

### `always`

Requires that all returned promises are `await`ed.

Examples of **incorrect** code with `always`:

```ts
async function invalidAlways1() {
<<<<<<< HEAD
=======
async function validAlways2() {
  return await Promise.resolve('try');
}

async function validAlways3() {
  return 'value';
}

// valid never
async function validNever1() {
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  try {
    return Promise.resolve('try');
  } catch (e) {}
}

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
async function invalidAlways2() {
  return Promise.resolve('try');
}

async function invalidAlways3() {
  return await 'value';
}
```

Examples of **correct** code with `always`:

```ts
async function validAlways1() {
  try {
    return await Promise.resolve('try');
  } catch (e) {}
}

async function validAlways2() {
  return await Promise.resolve('try');
}

async function validAlways3() {
  return 'value';
}
```

### `never`

Disallows all `await`ing any returned promises.

Examples of **incorrect** code with `never`:

```ts
<<<<<<< HEAD
=======
async function validNever2() {
  return Promise.resolve('try');
}

async function validNever3() {
  return 'value';
}
```

```typescript
// invalid in-try-catch
async function invalidInTryCatch1() {
  try {
    return Promise.resolve('try');
  } catch (e) {}
}

async function invalidInTryCatch2() {
  return await Promise.resolve('try');
}

async function invalidInTryCatch3() {
  return await 'value';
}

// invalid always
async function invalidAlways1() {
  try {
    return Promise.resolve('try');
  } catch (e) {}
}

async function invalidAlways2() {
  return Promise.resolve('try');
}

async function invalidAlways3() {
  return await 'value';
}

// invalid never
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
async function invalidNever1() {
  try {
    return await Promise.resolve('try');
  } catch (e) {}
}

async function invalidNever2() {
  return await Promise.resolve('try');
}

async function invalidNever3() {
  return await 'value';
}
```

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
Examples of **correct** code with `never`:

```ts
async function validNever1() {
  try {
    return Promise.resolve('try');
  } catch (e) {}
}

async function validNever2() {
  return Promise.resolve('try');
}

async function validNever3() {
  return 'value';
<<<<<<< HEAD
=======
The rule also applies to `finally` blocks. So the following would be invalid with default options:

```typescript
async function invalid() {
  try {
    return await Promise.resolve('try');
  } catch (e) {
    return Promise.resolve('catch');
  } finally {
    // cleanup
  }
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
}
```
