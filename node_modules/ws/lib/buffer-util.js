'use strict';

<<<<<<< HEAD
<<<<<<< HEAD
=======
const { EMPTY_BUFFER } = require('./constants');

>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
<<<<<<< HEAD
<<<<<<< HEAD
function concat (list, totalLength) {
=======
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
function concat (list, totalLength) {
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  const target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
<<<<<<< HEAD
<<<<<<< HEAD
function _mask (source, mask, output, offset, length) {
=======
function _mask(source, mask, output, offset, length) {
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
function _mask (source, mask, output, offset, length) {
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
<<<<<<< HEAD
<<<<<<< HEAD
function _unmask (buffer, mask) {
=======
function _unmask(buffer, mask) {
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
function _unmask (buffer, mask) {
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

<<<<<<< HEAD
<<<<<<< HEAD
=======
/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  var buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = viewToBuffer(data);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

/**
 * Converts an `ArrayBuffer` view into a buffer.
 *
 * @param {(DataView|TypedArray)} view The view to convert
 * @return {Buffer} Converted view
 * @private
 */
function viewToBuffer(view) {
  const buf = Buffer.from(view.buffer);

  if (view.byteLength !== view.buffer.byteLength) {
    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }

  return buf;
}

>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
try {
  const bufferUtil = require('bufferutil');
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
    mask (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    unmask (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    },
    concat
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = { concat, mask: _mask, unmask: _unmask };
<<<<<<< HEAD
=======
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
}
